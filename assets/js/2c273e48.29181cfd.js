"use strict";(globalThis.webpackChunkmicroservices_docs=globalThis.webpackChunkmicroservices_docs||[]).push([[355],{6042:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"catalog/message_service/architecture","title":"Architecture","description":"Internal Design","source":"@site/docs/catalog/message_service/architecture.md","sourceDirName":"catalog/message_service","slug":"/catalog/message_service/architecture","permalink":"/docs/catalog/message_service/architecture","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"backend","permalink":"/docs/tags/backend"},{"inline":true,"label":"ruby","permalink":"/docs/tags/ruby"},{"inline":true,"label":"opensearch","permalink":"/docs/tags/opensearch"},{"inline":true,"label":"sidekiq","permalink":"/docs/tags/sidekiq"},{"inline":true,"label":"kafka","permalink":"/docs/tags/kafka"},{"inline":true,"label":"mongo","permalink":"/docs/tags/mongo"}],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20,"title":"Architecture","authors":["Mattia Orfano"],"tags":["backend","ruby","opensearch","sidekiq","kafka","mongo"]},"sidebar":"tutorialSidebar","previous":{"title":"Overview & Purpose","permalink":"/docs/catalog/message_service/intro"},"next":{"title":"Data Model","permalink":"/docs/catalog/message_service/data_model"}}');var t=n(4848),r=n(8453);const a={sidebar_position:20,title:"Architecture",authors:["Mattia Orfano"],tags:["backend","ruby","opensearch","sidekiq","kafka","mongo"]},l=void 0,o={},c=[{value:"Internal Design",id:"internal-design",level:2},{value:"Entities &amp; Callbacks",id:"entities--callbacks",level:2},{value:"Ticket",id:"ticket",level:3},{value:"Message",id:"message",level:3},{value:"Origin",id:"origin",level:3},{value:"Queue",id:"queue",level:3},{value:"Background Workers",id:"background-workers",level:2},{value:"Sidekiq Jobs",id:"sidekiq-jobs",level:3},{value:"Kafka Consumers",id:"kafka-consumers",level:3},{value:"Configurations",id:"configurations",level:2}];function d(e){const s={em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h2,{id:"internal-design",children:"Internal Design"}),"\n",(0,t.jsx)(s.p,{children:"Message Service follows a modular architecture and has the following components:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"API"}),": offers RESTful endpoints for read/write operations on supported entities","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"built upon Grape, a simple DSL to easily develop RESTful APIs in 30 seconds or less"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Consumers"}),": elaborates Kafka events for incoming messages and updates on supported entities","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"built upon Karafka, a multi-threaded Kafka processing framework"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Models"}),": defines entities and their relationships stored within Mongo documents","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"built upon Mongoid, the Mapper framework for MongoDB"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Jobs"}),": background jobs handled by Sidekiq","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"each Job can run on a different Redis queue, with higher or lower priority, and different retry options"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Services"}),": business logic for different types of operations on tickets, messagges, origins e queues","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"each service follows the Command Pattern and business logic is wrapped into a sequential set of operations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Every touchpoint (API, Kafka consumer, Job) is isolated, meaning it works in conjuction with the current tenant from which a request comes from. This ensures that users and agents will see only data the belongs to them."}),"\n",(0,t.jsx)(s.h2,{id:"entities--callbacks",children:"Entities & Callbacks"}),"\n",(0,t.jsx)(s.p,{children:"It's important to understand what are the main entities and their respective callbacks (automatic events that are triggered before/after updates)."}),"\n",(0,t.jsx)(s.h3,{id:"ticket",children:"Ticket"}),"\n",(0,t.jsx)(s.p,{children:"A ticket represents a customer case. It contains:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Messagges from customers and agents"}),"\n",(0,t.jsx)(s.li,{children:"Status informations (created, working, pending, followup, solved, closed)"}),"\n",(0,t.jsx)(s.li,{children:"Owner (who's the agent working on it and its group)"}),"\n",(0,t.jsx)(s.li,{children:"Metadata (sentiment, timestamps, etc)"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"A ticket can be organized in Queues by automatic rules that are evaluated when the message arrives."}),"\n",(0,t.jsx)(s.p,{children:"Some ticket properties are automatically generated and assigned:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:"sequence"})," is a unique identifier within the same Tenant"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:"star_rating"})," is the latest customer rating (when applicable, such as Trustpilot Reviews)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:"count of visible messages"}),": the number of messages that are NOT shadowed (explained below)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:"metadata"}),": timestamps"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"After a Ticket gets created or updated, a Sidekiq async job ensures that Opensearch indexes are up-to-date."}),"\n",(0,t.jsx)(s.p,{children:"Since a small property change could invalidate the association between a ticket and a queue (based on conditions defined in the Queue itself), a ticket is always removed from its queues when updated, and sent to rules engine that will later decide where to assign it. This mechanism ensures that every Queue always contains the expected tickets."}),"\n",(0,t.jsx)(s.h3,{id:"message",children:"Message"}),"\n",(0,t.jsx)(s.p,{children:"A message represents a single interaction inside a ticket. It can be:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Message from the social network (written by a customer)"}),"\n",(0,t.jsx)(s.li,{children:"Agent's reply (written from Chorally to the customer)"}),"\n",(0,t.jsx)(s.li,{children:"Private Note (only visible to agents)"}),"\n",(0,t.jsx)(s.li,{children:"AI-generated message"}),"\n",(0,t.jsx)(s.li,{children:"AI-generated suggestion (only visible to agents)"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Messagges can include attachments."}),"\n",(0,t.jsx)(s.p,{children:"A message can be deleted, hide (for moderation) or shadowed (if the corresponding Origin is disabled, new messages are always pulled into Chorally but they are not shown until the Origin gets re-activated again)."}),"\n",(0,t.jsx)(s.p,{children:"Messages are grouped together in threads based on AUTHOR-ORIGIN pair; if the same person writes multiple messages over time, Chorally keeps track of these conversations via a unified thread. But different tickets might be created depending on the operations performed by agents."}),"\n",(0,t.jsx)(s.p,{children:"When a new message arrives, the systems performs a set of operations:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"find the corrisponding Origin (channel where the message belongs)"}),"\n",(0,t.jsx)(s.li,{children:"find or create Thread using Origin and Author"}),"\n",(0,t.jsx)(s.li,{children:"find or create the ticket (if same customer already has an active ticket, use that)"}),"\n",(0,t.jsx)(s.li,{children:"appends message to the ticket"}),"\n",(0,t.jsx)(s.li,{children:"changes ticket state following the state machine"}),"\n",(0,t.jsx)(s.li,{children:"set ticket properties if an applicable EnrichmentList exists"}),"\n",(0,t.jsx)(s.li,{children:"creates a log into the system, triggers rules engine"}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"origin",children:"Origin"}),"\n",(0,t.jsx)(s.p,{children:"An Origin represents a communication channel between the Business and its customers. Examples include:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Facebook (comments on wall, private messages)"}),"\n",(0,t.jsx)(s.li,{children:"Instagram (same as above)"}),"\n",(0,t.jsx)(s.li,{children:"X/Twitter"}),"\n",(0,t.jsx)(s.li,{children:"WhatsApp Messages"}),"\n",(0,t.jsx)(s.li,{children:"LinkedIn Comments"}),"\n",(0,t.jsx)(s.li,{children:"Mail"}),"\n",(0,t.jsx)(s.li,{children:"etc"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Every Origin has a state (can be disabled at any given time). Disabling an Origin does not prevent messages from being imported on channels that belongs to webhooks. They will be saved anyway but hidden from agents. This way they won't be lost if Business decides to re-enable Origin after a while."}),"\n",(0,t.jsx)(s.h3,{id:"queue",children:"Queue"}),"\n",(0,t.jsx)(s.p,{children:"A Queue helps organizing tickets that reflect specific properties/conditions. A queue can:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Be visible to specific groups or agents"}),"\n",(0,t.jsx)(s.li,{children:"Have counters for different ticket states"}),"\n",(0,t.jsx)(s.li,{children:"Sorted by priority"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"background-workers",children:"Background Workers"}),"\n",(0,t.jsx)(s.p,{children:"Message Service operates asynchronously in 2 ways:"}),"\n",(0,t.jsx)(s.h3,{id:"sidekiq-jobs",children:"Sidekiq Jobs"}),"\n",(0,t.jsx)(s.p,{children:"Jobs are operations that can be executed seprately from web requests and direct agents operations. They are regularly pushed/pulled from Redis queues, and includes:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Ticket Reindex"}),": searching on tickets is performed through Opensearch and indexes must be kept aligned. So every time a ticket changes, a job is enqueued to perform a reindex for that ticket."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Ticket Closure"}),": When a ticket hits the solved or pending state, it will be automatically closed after 24hours (unless a new message comes in)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Followup"}),': When a ticket is transitioned to Followup, it must goes back to "working" state after the specified period of time.']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Sync Queue Counters"}),": every time a Ticket is added or removed from a Queue, we must update the UI counters of that Queue (so agents instantly see the numbers of tickets growing in the queues). This is done asynchrounsly with a Job."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"kafka-consumers",children:"Kafka Consumers"}),"\n",(0,t.jsx)(s.p,{children:"Another type of async operations are realtime messages that arrives via Kafka. Message Service heavily relies on them to pull new messages from social networks (read the Kafka chapter for in-depth overview of this part)."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Messages"}),": Incoming messages from social networks or message-related ops (eg. remove)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Tickets"}),": Ticket-related events that might be triggered by rules engine (eg. set state)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Queues"}),": special consumer used to re-evaluate all tickets under a Queue when it gets updated"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"AI Messages"}),": events from AI Chatbot (automatic replies or suggestions)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Metadata"}),": detects changes to tag, topic and custom fields in order to update Queue-Ticket associations"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Escalation"}),": manages escalation events"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"configurations",children:"Configurations"}),"\n",(0,t.jsx)(s.p,{children:"These are required env variables:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Kafka (KAFKA_HOST, KAFKA_REPLICATION_FACTOR)"}),"\n",(0,t.jsx)(s.li,{children:"MongoDB (MONGODB_HOST, MONGODB_PORT, MONGODB_USERNAME, MONGODB_PASSWORD)"}),"\n",(0,t.jsx)(s.li,{children:"Redis (REDIS_DB_NUMBER, REDIS_HOST, REDIS_PORT, REDIS_USERNAME, REDIS_PASSWORD, REDIS_CLUSTER, REDIS_SENTINEL_USERNAME, REDIS_SENTINEL_PASSWORD, REDIS_CLUSTER_PORT)"}),"\n",(0,t.jsx)(s.li,{children:"OpenSearch (OPENSEARCH_HOST, OPENSEARCH_PORT, OPENSEARCH_USERNAME, OPENSEARCH_PASSWORD)"}),"\n",(0,t.jsx)(s.li,{children:"Application-specific (MESSAGE_SERVICE_ENV, TICKET_CLOSED_AFTER_MINS, SIDEKIQ_MAX_RETRIES, ADMIN_TOKEN_SECRET)"}),"\n",(0,t.jsx)(s.li,{children:"External services URLs (USER_SERVICE_URL, TICKET_HELPER_SERVICE_URL, AITOOLBOX_SERVICE_URL)"}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var i=n(6540);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);